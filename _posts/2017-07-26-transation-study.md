---
layout: post
title: 简说分布式事务
categories: 分布式
description: 分布式事务
keywords: 分布式事务
---

## 传统系统事务实现机制

**举个栗子：**这里我们拿一个很常规的转账操作来模拟一下，在规模较小的系统中，表都在一个数据库实例中，我们可以轻松的实现事务的控制。比如A账户给B账户转账100元钱，我们需要做的操作是A账户扣100元，同时给B账户加100元。
SQL语句为:

update table set amount=amount-100 where user='A'；

update table set amount=amount+100 where user='B'；

用事务解决的话就是：

```java
Begin transaction
         update table set amount=amount-100 where user='A'；
         update table set amount=amount+100 where user='B'；
End transaction
commit;
```
另外我们也可以用spring很轻松的实现，加个注解就可以了。

## 两阶段提交协议 
但是目前随着互联网技术的飞速发展，单一系统明显不能满足业务的需求（这里假设A、B账户分处在两个系统数据库中），如何在分布式系统中去保证上述的问题就成了一个难题。

两阶段提交协议（Two-phase Commit，2PC）被广泛的应用于分布式事务中来。这种分布式事务的实现方式包括一个调度器和若干个事务执行者组成。如下图所示：
![](/images/transation1.png)

**在这种协议中，当一个请求到达调度器TC中来之后，TC会像2个事务执行者各发一条prepare消息去通知他们执行各自的操作（扣款和加款），同时将在发送消息前需要写一条日志去记录下这一次请求，目的是为了系统崩溃后可以不丢失这一次行为。

2个SI执行完各自的操作后，并不会进行commit的操作，而是返回TC各自的执行结果，同时记录下这次操作的记录。
	
TC收集完2个SI的操作返回后，如果2个SI都执行成功的话会再向2个事务执行者发送commit信息，否则则发送rollback操作。SI收到信息后执行各自的操作。
	
这种协议解决了分布式事务的问题，也被大量使用。但是这种协议同时也暴露出一定的问题：
	
（1）各系统间通信次数较多，一定程度上拖慢了系统的速度。
（2）一次操作耗时时间较长，这对目前的互联网企业的分布式系统来说是不能容忍的。
（3）会留下大量的log。

正是由于分布式事务存在很严重的性能问题，大部分高并发服务都在避免使用，往往通过其他途径来解决数据一致性问题。

## 使用消息队列来解决数据一致性
目前有2种方式来解决这一问题：

**业务与消息耦合的方式：

A账户在完成扣款的同时，同时记录消息数据，这个消息数据与业务数据保存在同一数据库实例里（消息记录表表名为message）。
```java
Begin transaction
         update table set amount=amount-100 where user='A'；
         insert into message(userId, amount,status) values(1, 100, 1);
End transaction
commit;
```

这样能保证只要发生了扣款操作，就一定会生成一条消息。
当上述事务提交成功后，我们通过实时消息服务将此消息通知B账户系统，B账户系统处理成功后发送回复成功消息，A账户系统收到回复后删除该条消息数据。

**业务与消息解耦方式：

上述保存消息的方式使得消息数据和业务数据紧耦合在一起，从架构上看不够优雅，而且容易诱发其他问题。为了解耦，可以采用以下方式。
（1）A系统发生扣款，但并不提交，向消息服务推送一条消息，但是并不真正发送这条消息。

（2）A系统扣款操作提交后向消息系统发送确认发送的消息，消息系统发送此条消息。

（3）如果扣款操作提交失败，则不会发送此消息。

（4）对于那些未确认的消息或者取消的消息，需要有一个消息状态确认系统定时去A系统查询这个消息的状态并进行更新。为什么需要这一步骤，举个例子：假设在第2步扣款事务被成功提交后，系统挂了，此时消息状态并未被更新为“确认发送”，从而导致消息不能被发送。
![](/images/transation2.png)

还有一个很严重的问题就是消息重复投递，以我们支付宝转账到余额宝为例，如果相同的消息被重复投递两次，那么我们余额宝账户将会增加2万而不是1万了。这里面涉及到消费者接口的幂等性设计，简单来说，一个操作如果具有任意多次执行所产生的影响均与一次执行的影响相同，我们就称之为幂等。可见参考资料：https://mp.weixin.qq.com/s/EDkuMW5-hdIxs2GXMFnj_Q

为什么相同的消息会被重复投递？比如余额宝处理完消息msg后，发送了处理成功的消息给支付宝，正常情况下支付宝应该要删除消息msg，但如果支付宝这时候悲剧的挂了，重启后一看消息msg还在，就会继续发送消息msg。

解决方法很简单，在余额宝这边增加消息应用状态表（message_apply），通俗来说就是个账本，用于记录消息的消费情况，每次来一个消息，在真正执行之前，先去消息应用状态表中查询一遍，如果找到说明是重复消息，丢弃即可，如果没找到才执行，同时插入到消息应用状态表（同一事务）。